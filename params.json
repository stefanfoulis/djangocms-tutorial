{"name":"Djangocms-tutorial","tagline":"djangoCMS Tutorial for PyCon.DE [WIP]","body":"djangoCMS Tutorial\r\n==================\r\n\r\nPrerequisites / Requirements\r\n----------------------------\r\n* python\r\n* git\r\n* pip\r\n* ..more?\r\n\r\nStart\r\n-----\r\nIn order to start, you first need to clone this repository. Open a shell,\r\ncd into your workspace and git clone the tutorial\r\n\r\n```bash\r\ncd ~/workspace\r\ngit clone git@github.com:Chive/djangocms-tutorial.git\r\ncd djangocms-tutorial\r\n```\r\n\r\nNow checkout branch [`step-1`](https://github.com/Chive/djangocms-tutorial/tree/step-1) to get going!\r\n\r\n```bash\r\ngit checkout step-1\r\n```\r\n\r\ndjangoCMS Tutorial - Step 1\r\n===========================\r\nHey, you made it! Awesome. Now let's get started by setting up our environment.\r\n\r\nPreparing your workstation\r\n--------------------------\r\n\r\n```bash\r\n$ pip install --upgrade virtualenv\r\n```\r\nInstalling the CMS\r\n------------------\r\n\r\n### Make a project folder\r\n\r\n```bash\r\n$ cd ~/workspace\t\r\n$ mkdir demo && cd demo\r\n```\r\n\r\n### Setup virtual environment\r\n\r\n```bash\r\n$ virtualenv env --no-site-packages\r\n$ source env/bin/activate\r\n$ pip install -e git+https://github.com/nephila/aldryn-installer#egg=aldryn-installer\r\n```\r\n\r\n### install djangoCMS\r\nfollow the interactive setup, don't worry if takes a while :)\r\n\r\n```bash\r\n$ aldryn -p . my_demo\r\n```\r\n\r\nIf you want to be safe, use the settings below:\r\n\r\n```bash\r\n§ Database configuration (in URL format) [default sqlite://locahost/project.db]: [ENTER]\r\n§ django CMS version (choices: 2.4, stable, beta, develop) [default stable]: develop\r\n§ Django version (choices: 1.4, 1.5, stable) [default stable]: 1.5\r\n§ Activate Django I18N / L10N setting (choices: yes, no) [default yes]: [ENTER]\r\n§ Install and configure reversion support (choices: yes, no) [default yes]: [ENTER]\r\n§ Languages to enable. Option can be provided multiple times, or as a comma separated list: en,de\r\n§ Optional default timezone [default America/Chicago]: Europe/Zurich\r\n§ Activate Django timezone support (choices: yes, no) [default yes]: [ENTER]\r\n§ Activate CMS permission management (choices: yes, no) [default yes]: [ENTER]\r\n\r\n§ Username: admin\r\n§ Email address: admin@example.com \r\n§ Password: admin\r\n```\r\n\r\n### let's run it\r\n```bash\r\n$ python manage.py runserver\r\n```\r\n\r\n### Where to go from here\r\n\r\nCongratulations, you now have a fully functional CMS! Awesome job! Let's continue by checking out branch [`step-2`](https://github.com/Chive/djangocms-tutorial/tree/step-2) (You should know how that works by now :)\r\n\r\ndjangoCMS Tutorial - Step 2\r\n===========================\r\nStill with us? Great! So far we set up our environment by installing django, djangoCMS and all necessary dependencies. We also configured djangoCMS and ran it for the first time.\r\n\r\nNext up, we want to extend djangoCMS by installing an app. We're gonna be using the aldryn_blog module for this example. Let's get going!\r\n\r\nAt first, we need to install the extension from the python Package Index (remember, always in the virtual environment!):\r\n\r\n```bash\r\n$ source env/bin/activate\r\n$ pip install aldryn-blog\r\n```\r\n\r\nAdd the apps below to `INSTALLED_APPS` in `settings.py`:\r\n\r\n```python\r\nINSTALLED_APPS = [\r\n    …\r\n    'aldryn_blog',\r\n    'django_select2',\r\n    'djangocms_text_ckeditor',\r\n    'easy_thumbnails',\r\n    'filer',\r\n    'taggit',\r\n    …\r\n]\r\n```\r\nSince we added a new app, we need to update our database. Thankfully, django comes with set of awesome tools which do most of the job. We just need to run the following two commands:\r\n\r\n```bash\r\n$ python manage.py syncdb\r\n$ python manage.py migrate\r\n```\r\n\r\nand it's done.\r\n\r\nFinally, we need to copy a html template for our blog to our project:\r\n\r\n```bash\r\ncp ../djangocms-tutorial/sources/base.html my_demo/templates/\r\n```\r\n\r\nWe can now run our server again\r\n\r\n```bash\r\n$ python manage.py runserver\r\n```\r\nNow go to the admin panel at [localhost:8000/admin](http://localhost:8000/admin) and\r\n\r\n* Go to _Cms_ > _Pages_ and add a new page\r\n* Go to the advanced settings of the page we just created\r\n* Under _Application_, select the 'Blog' application and give it a namespace (e.g. `myblog`)\r\n* Save and publish the page\r\n* Restart the server (`CTRL+C` and `python manage.py runserver` again)\r\n* Now go to _Aldryn Blog_ and add a new post\r\n* Voila :)\r\n\r\nQuick, check out [`step-3`](https://github.com/Chive/djangocms-tutorial/tree/step-3)!\r\n\r\ndjangoCMS Tutorial - Step 3\r\n===========================\r\nIn this part of the tutorial we're going to take a django app and modify it like that so we can use it in the CMS. We're gonna use the django-poll app.\r\n\r\nYou can either complete the tutorial here <https://docs.djangoproject.com/en/dev/intro/tutorial01/> or copy the folder `polls` from `djangocms-tutorial/sources/` to your project root.\r\n\r\n```bash\r\n~/workspace/demo $ cp -r ../djangocms-tutorial/sources/polls .\r\n```\r\n\r\nYou should end up with this folder structure:\r\n\r\n```\r\nworkspace\r\n\tdjangocms-tutorial/\r\n\tmy_demo/\r\n\t\tenv/\r\n\t\tmanage.py\r\n\t\tmy_demo/\r\n\t\t\t__init__.py\r\n\t\t\tsettings.py\r\n\t\t\ttemplates/\r\n\t\t\t\tbase.html\r\n\t\t\t\tindex.html\r\n\t\t\t\tpage.html\r\n\t\t\turls.py\r\n\t\t\twsgi.py\r\n\t\tpolls/\r\n\t\t\tREADME.md\r\n\t\t\t__init__.py\r\n\t\t\tadmin.py\r\n\t\t\tmodels.py\r\n\t\t\ttemplates/\r\n\t\t\t\tpolls/\r\n\t\t\t\t\tdetail.html\r\n\t\t\t\t\tindex.html\r\n\t\t\t\t\tresults.html\r\n\t\t\ttests.py\r\n\t\t\turls.py\r\n\t\t\tviews.py\r\n\t\tproject.db\r\n\t\trequirements.txt\r\n```\r\n\r\nOur first plugin\r\n----------------\r\n\r\n### The Model\r\nFor our polling app we would like to have a small poll plugin which shows a poll and lets the user vote.\r\n\r\nIn your poll application’s `models.py` add the following:\r\n\r\n```python\r\nfrom cms.models import CMSPlugin\r\n\r\nclass PollPlugin(CMSPlugin):\r\n    poll = models.ForeignKey('polls.Poll', related_name='plugins')\r\n\r\n    def __unicode__(self):\r\n      return self.poll.question\r\n```\r\n\r\n**Note:** django CMS plugins must inherit from `cms.models.CMSPlugin` (or a subclass thereof) and not `models.Model`.\r\n\r\n### The Plugin Class\r\nNow create a file `cms_plugins.py` in the same folder your models.py is in. The plugin class is responsible for providing the django CMS with the necessary information to render your Plugin.\r\n\r\nFor our poll plugin, write the following plugin class:\r\n\r\n```python\r\nfrom cms.plugin_base import CMSPluginBase\r\nfrom cms.plugin_pool import plugin_pool\r\nfrom polls.models import PollPlugin as PollPluginModel\r\nfrom django.utils.translation import ugettext as _\r\n\r\nclass PollPlugin(CMSPluginBase):\r\n    model = PollPluginModel # Model where data about this plugin is saved\r\n    name = _(\"Poll Plugin\") # Name of the plugin\r\n    render_template = \"polls/plugin.html\" # template to render the plugin with\r\n\r\n    def render(self, context, instance, placeholder):\r\n        context.update({'instance':instance})\r\n        return context\r\n\r\nplugin_pool.register_plugin(PollPlugin) # register the plugin\r\n```\r\n\r\n**Note**: All plugin classes must inherit from `cms.plugin_base.CMSPluginBase` and must register themselves with the `cms.plugin_pool.plugin_pool`.\r\n\r\n### The Template\r\nYou probably noticed the render_template attribute in the above plugin class. In order for our plugin to work, that template must exist and is responsible for rendering the plugin.\r\n\r\nThe template is located at `polls/templates/polls/plugin.html` and should look something like this:\r\n\r\n```html\r\n<h1>{{ instance.poll.question }}</h1>\r\n\r\n<form action=\"{% url polls.views.vote instance.poll.id %}\" method=\"post\">\r\n\t{% csrf_token %}\r\n\t{% for choice in instance.poll.choice_set.all %}\r\n    \t<input type=\"radio\" name=\"choice\" id=\"choice{{ forloop.counter }}\" value=\"{{ choice.id }}\" />\r\n\t\t<label for=\"choice{{ forloop.counter }}\">{{ choice.choice }}</label><br />\r\n\t{% endfor %}\r\n\t<input type=\"submit\" value=\"Vote\" />\r\n</form>\r\n```\r\n\r\n**Note**: We don’t show the errors here, because when submitting the form you’re taken off this page to the actual voting page.\r\n\r\nQuite some work done by now, let's add it to our project. Add your polls plugin to the `INSTALLED_APPS` in your projects `settings.py`:\r\n\r\n```python\r\nINSTALLED_APPS = (\r\n\r\n\t...\r\n\t\r\n    'polls',\r\n    \r\n    ...\r\n)\r\n```\r\n\r\nSecondly, add it to the project's `urls.py` so it looks something like this:\r\n\r\n```python\r\nurlpatterns = i18n_patterns('',\r\n    url(r'^admin/', include(admin.site.urls)),\r\n    url(r'^polls/', include('polls.urls')),\r\n    url(r'^sitemap\\.xml$', 'django.contrib.sitemaps.views.sitemap', {'sitemaps': {'cmspages': CMSSitemap}}),\r\n    url(r'^', include('cms.urls')),\r\n)\r\n```\r\n\r\nNow to create the database tables for this model (using South):\r\n\r\n```bash\r\n$ python manage.py schemamigration polls --initial\r\n$ python manage.py migrate polls\r\n```\r\n\r\nFinally, run the server and go visit <http://localhost:8000/polls/>. Yay!\r\n\r\n\r\n### My First App (apphook)\r\nRight now, external apps are statically hooked into the main `urls.py`. This is not the preferred approach in the django CMS. Ideally you attach your apps to CMS pages.\r\n\r\nFor that purpose you write a CMSApp. That is just a small class telling the CMS how to include that app.\r\n\r\nCMS Apps live in a file called `cms_app.py`, so go ahead and create it to make your polls app look like this:\r\n\r\n```\r\npolls/\r\n    __init__.py\r\n    cms_app.py\r\n    cms_plugins.py\r\n    models.py\r\n    tests.py\r\n    views.py\r\n```\r\n\r\nIn this file, write:\r\n\r\n```python\r\nfrom cms.app_base import CMSApp\r\nfrom cms.apphook_pool import apphook_pool\r\nfrom django.utils.translation import ugettext_lazy as _\r\n\r\nclass PollsApp(CMSApp):\r\n    name = _(\"Poll App\") # give your app a name, this is required\r\n    urls = [\"polls.urls\"] # link your app to url configuration(s)\r\n\r\napphook_pool.register(PollsApp) # register your app\r\n```\r\n\r\nNow remove the inclusion of the polls urls in your project's `urls.py` so it looks like this:\r\n\r\n```python\r\nurlpatterns = i18n_patterns('',\r\n    url(r'^admin/', include(admin.site.urls)),\r\n    url(r'^sitemap\\.xml$', 'django.contrib.sitemaps.views.sitemap', {'sitemaps': {'cmspages': CMSSitemap}}),\r\n    url(r'^', include('cms.urls')),\r\n)\r\n```\r\n\r\nNow open your admin in your browser and edit a CMS Page. Open the ‘Advanced Settings’ tab and choose ‘Polls App’ for your ‘Application’. Just like we did with the blog some minutes ago.\r\n\r\nAgain, for these changes to take effect, you will have to restart your server. So do that and afterwards if you navigate to that CMS Page, you will see your polls application.\r\n\r\n### My First Menu\r\nNow you might have noticed that the menu tree stops at the CMS Page you created in the last step. So let’s create a menu that shows a node for each poll you have active.\r\n\r\nFor this we need a file called `menu.py`. Create it and ensure your polls app looks like this:\r\n\r\n````\r\npolls/\r\n    __init__.py\r\n    cms_app.py\r\n    cms_plugins.py\r\n    menu.py\r\n    models.py\r\n    tests.py\r\n    views.py\r\n```\r\n\r\nIn your `menu.py` write:\r\n\r\n```python\r\nfrom cms.menu_bases import CMSAttachMenu\r\nfrom menus.base import Menu, NavigationNode\r\nfrom menus.menu_pool import menu_pool\r\nfrom django.core.urlresolvers import reverse\r\nfrom django.utils.translation import ugettext_lazy as _\r\nfrom polls.models import Poll\r\n\r\nclass PollsMenu(CMSAttachMenu):\r\n    name = _(\"Polls Menu\") # give the menu a name, this is required.\r\n\r\n    def get_nodes(self, request):\r\n        \"\"\"\r\n        This method is used to build the menu tree.\r\n        \"\"\"\r\n        nodes = []\r\n        for poll in Poll.objects.all():\r\n            # the menu tree consists of NavigationNode instances\r\n            # Each NavigationNode takes a label as its first argument, a URL as\r\n            # its second argument and a (for this tree) unique id as its third\r\n            # argument.\r\n            node = NavigationNode(\r\n                poll.question,\r\n                reverse('polls.views.detail', args=(poll.pk,)),\r\n                poll.pk\r\n            )\r\n            nodes.append(node)\r\n        return nodes\r\nmenu_pool.register_menu(PollsMenu) # register the menu.\r\n```\r\n\r\nAt this point this menu alone doesn’t do a whole lot. We have to attach it to the Apphook first.\r\n\r\nSo open your `cms_apps.py` and write:\r\n\r\n```python\r\nfrom cms.app_base import CMSApp\r\nfrom cms.apphook_pool import apphook_pool\r\nfrom polls.menu import PollsMenu\r\nfrom django.utils.translation import ugettext_lazy as _\r\n\r\nclass PollsApp(CMSApp):\r\n    name = _(\"Poll App\")\r\n    urls = [\"polls.urls\"]\r\n    menus = [PollsMenu] # attach a CMSAttachMenu to this apphook.\r\n    app_name = 'polls'\r\n\r\napphook_pool.register(PollsApp)\r\n```\r\n\r\n\r\nPhew, quite some work done. If you're still on fire, check out branch [`step-4`](https://github.com/Chive/djangocms-tutorial/tree/step-4)!\r\n\r\ndjangoCMS Tutorial - Step 4\r\n===========================\r\nExtending the Toolbar\r\n---------------------\r\nIn the new version 3.0 you can add and remove items to the toolbar. This allows you to integrate your application in the frontend editing mode of django CMS and provide your users with a streamlined editing experience.\r\n\r\n### Registering\r\nThere are two ways to control what gets shown in the toolbar.\r\n\r\nOne is the `CMS_TOOLBARS`. This gives you full control over which classes are loaded, but requires that you specify them all manually.\r\n\r\nThe other is to provide `cms_toolbar.py` files in your apps, which will be automatically loaded as long `CMS_TOOLBARS` is not set (or set to `None`).\r\n\r\nIf you use the automated way, your `cms_toolbar.py` file should contain classes that extend from `cms.toolbar_base.CMSToolbar` and are registered using `cms.toolbar_pool.toolbar_pool.register()`. The register function can be used as a decorator.\r\n\r\nThese have four attributes:\r\n\r\n* `toolbar` (the toolbar object)\r\n* `request` (the current request)\r\n* `is_current_app` (a flag indicating whether the current request is handled by the same app as the function is in)\r\n* `app_path` (the name of the app used for the current request)\r\n\r\nThis classes must implement a populate function. The populate function will only be called if the current user is a staff user.\r\n\r\nA simple example, registering a class that does nothing:\r\n\r\n```python\r\nfrom cms.toolbar_pool import toolbar_pool\r\nfrom cms.toolbar_base import CMSToolbar\r\n\r\n@toolbar_pool.register\r\nclass MoopModifier(CMSToolbar):\r\n\r\n    def populate(self):\r\n        pass\r\n```\r\n\r\n### Adding items\r\nItems can be added through the various APIs exposed by the toolbar and its items.\r\n\r\nTo add a `cms.toolbar.items.Menu` to the toolbar, use `cms.toolbar.toolbar.CMSToolbar.get_or_create_menu()` which will either add a menu if it doesn’t exist, or create it.\r\n\r\nThen, to add a link to your changelist that will open in the sideframe, use the `cms.toolbar.items.ToolbarMixin.add_sideframe_item()` method on the menu object returned.\r\n\r\nWhen adding items, all arguments other than the name or identifier should be given as keyword arguments. This will help ensure that your custom toolbar items survive upgrades.\r\n\r\nFollowing our Extending the CMS: Examples, let’s add the poll app to the toolbar:\r\n\r\n```python\r\nfrom django.core.urlresolvers import reverse\r\nfrom django.utils.translation import ugettext_lazy as _\r\nfrom cms.toolbar_pool import toolbar_pool\r\nfrom cms.toolbar_base import CMSToolbar\r\n\r\n@toolbar_pool.register\r\nclass PollToolbar(CMSToolbar):\r\n\r\n    def populate(self):\r\n        if self.is_current_app:\r\n            menu = self.toolbar.get_or_create_menu('poll-app', _('Polls'))\r\n            url = reverse('admin:polls_poll_changelist')\r\n            menu.add_sideframe_item(_('Poll overview'), url=url)\r\n```\r\n\r\nHowever, there’s already a menu added by the CMS which provides access to various admin views, so you might want to add your menu as a sub menu there. To do this, you can use positional insertion coupled with the fact that `cms.toolbar.toolbar.CMSToolbar.get_or_create_menu()` will return already existing menus:\r\n\r\n```python\r\nfrom django.core.urlresolvers import reverse\r\nfrom django.utils.translation import ugettext_lazy as _\r\nfrom cms.toolbar_pool import toolbar_pool\r\nfrom cms.toolbar.items import Break\r\nfrom cms.cms_toolbar import ADMIN_MENU_IDENTIFIER, ADMINISTRATION_BREAK\r\nfrom cms.toolbar_base import CMSToolbar\r\n\r\n@toolbar_pool.register\r\nclass PollToolbar(CMSToolbar):\r\n\r\n    def populate(self):\r\n        admin_menu = self.toolbar.get_or_create_menu(ADMIN_MENU_IDENTIFIER, _('Site'))\r\n        position = admin_menu.find_first(Break, identifier=ADMINISTRATION_BREAK)\r\n        menu = admin_menu.get_or_create_menu('poll-menu', _('Polls'), position=position)\r\n        url = reverse('admin:polls_poll_changelist')\r\n        menu.add_sideframe_item(_('Poll overview'), url=url)\r\n        admin_menu.add_break('poll-break', position=menu)\r\n```\r\n\r\n### Adding items through views\r\nAnother way to add items to the toolbar is through our own views (`polls/views.py`). This method can be useful if you need to access certain variables, in our case e.g. the selected poll and its sub-methods:\r\n\r\n```python\r\nfrom django.core.urlresolvers import reverse\r\nfrom django.shortcuts import get_object_or_404, render\r\nfrom django.utils.translation import ugettext_lazy as _\r\n\r\nfrom polls.models import Poll\r\n\r\n\r\ndef detail(request, poll_id):\r\n    poll = get_object_or_404(Poll, pk=poll_id)\r\n\r\n    request.toolbar.populate()\r\n    menu = request.toolbar.get_or_create_menu('polls-app', _('Polls'))\r\n    menu.add_modal_item(_('Change this Poll'), url=reverse('admin:polls_poll_change', args=[poll_id]))\r\n    menu.add_sideframe_item(_('Show History of this Poll'), url=reverse('admin:polls_poll_history', args=[poll_id]))\r\n    menu.add_sideframe_item(_('Delete this Poll'), url=reverse('admin:polls_poll_delete', args=[poll_id]))\r\n\r\n    return render(request, 'polls/detail.html', {'poll': poll})\r\n```\r\n\r\nstep-5: extending the page model\r\n\r\ndjangoCMS Tutorial - Step 5\r\n===========================\r\nExtending the page model\r\n------------------------\r\nCreate a new python module in your project root - let's call it `pagetags`. Add all the files below:\r\n\r\n```\r\npagetags/\r\n\t__init.py__\r\n\tadmin.py\r\n\tcms_toolbar.py\r\n\tmodels.py\r\n```\r\n\r\n\r\n### The Model\r\nAt first, we're gonna set up the model. To do so, open up `models.py`, create a class extending `cms.extensions.PageExtension` and make a `tags` field of the type `taggit.managers.TaggableManager`. Afterwards, register the class in the `cms.extensions.extension_pool`. It should look something like this:\r\n\r\n```python\r\nfrom cms.extensions import PageExtension, extension_pool\r\nfrom taggit.managers import TaggableManager\r\n\r\n\r\nclass PageTag(PageExtension):\r\n    tags = TaggableManager()\r\n\r\nextension_pool.register(PageTag)\r\n```\r\n\r\n### The Admin\r\nLet's make a very simple admin class in the `admin.py`.\r\n\r\n```python\r\nfrom cms.extensions import PageExtensionAdmin\r\nfrom django.contrib import admin\r\nfrom .models import PageTag\r\n\r\n\r\nclass PageTagAdmin(PageExtensionAdmin):\r\n    list_display = ('extended_object')\r\n\r\nadmin.site.register(PageTag, PageTagAdmin)\r\n```\r\n\r\nOh wait, let's add a method to the `PageTagAdmin` class, so we can see whether the tags where added to a draft page or not:\r\n\r\n```python\r\n    def is_draft_page(self, obj):\r\n        return obj.extended_object.publisher_is_draft\r\n```\r\n\r\n### The Toolbar\r\nLet's get to the fun part: Putting it all together and adding it to the toolbar!\r\n\r\n```python\r\nfrom django.core.urlresolvers import reverse, NoReverseMatch\r\nfrom django.utils.translation import ugettext_lazy as _\r\n\r\nfrom cms.api import get_page_draft\r\nfrom cms.toolbar_pool import toolbar_pool\r\nfrom cms.toolbar_base import CMSToolbar\r\nfrom .models import PageTag\r\n\r\n\r\n@toolbar_pool.register\r\nclass PageTagsToolbar(CMSToolbar):\r\n    def populate(self):\r\n        # always use draft if we have a page\r\n        self.page = get_page_draft(self.request.current_page)\r\n\r\n        if not self.page:\r\n            # Nothing to do\r\n            return\r\n\r\n        try:\r\n            page_tag = PageTag.objects.get(extended_object_id=self.page.id)\r\n        except PageTag.DoesNotExist:\r\n            page_tag = None\r\n        try:\r\n            if page_tag:\r\n                url = reverse('admin:pagetags_pagetag_change', args=(page_tag\r\n                                                                 .pk,))\r\n            else:\r\n                url = reverse('admin:pagetags_pagetag_add')+'?extended_object' \\\r\n                                                            '=%s' % self.page.pk\r\n        except NoReverseMatch:\r\n            # not in urls\r\n            pass\r\n        else:\r\n            not_edit_mode = not self.toolbar.edit_mode\r\n            current_page_menu = self.toolbar.get_or_create_menu('page')\r\n            current_page_menu.add_modal_item(_('Tags'), url=url,\r\n                                             disabled=not_edit_mode)\r\n```\r\n\r\nWhat we did here is # TODO: this.\r\n\r\ndjangoCMS Tutorial - Step 6\r\n===========================\r\nStacks: displaying the same content on multiple locations\r\n---------------------------------------------------------\r\nIf you need to display the same content on multiple locations you can use stacks.\r\n\r\nStacks have a name and a placeholder attached to them. There are 3 ways to use stacks.\r\n\r\n### 1. Stack Template Tags\t\r\nYou can use a template tag to display a placeholder in a template without the need for an actual placeholder on you models. This can be useful for:\r\n\t* Footer\r\n\t* Logo\r\n\t* Header\r\n\t* Text or content inside you app\r\n\t* Text or content inside of 3th party apps.\r\n\t\r\n**Example:**\r\n\t\r\n```python\r\n{% load stack_tags %} {% stack “footer” %}\r\n```\r\n\t\r\n***Note:*** It is recommended to use stacks in your apphook apps instead of show_placeholder templatetags\r\n\r\n### 2. Stack Plugins\r\n\r\nYou can create a stack out of plugins. You can create stacks out of plugin trees. After you created a stack this way you can insert a stack plugin and select a stack to be displayed instead of the stack plugin.\r\n\r\n### 3. Stacks as templates\r\n\r\nIf you create stacks out of plugin tree you can paste the plugins contained in a stack as template. For example you can create a teaser plugin tree out of a multicolumn, text and picture plugin. You can then paste this template at the appropriate place and just edit the plugins instead of creating the same structure over and over.\r\n\r\n\r\n`# TODO: improve\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}